#summary The use and algorithms of Global RDF Graphs.

= Global Graphs =

Global Graphs contrast with [GettingStarted local graphs] in that they do not require a node pool and unique identifiers for graph nodes.  This means that nodes can be used in a distributed environment.

= RDF Molecules =
RDF molecules represent a lossless decomposition of an RDF graph.  The main purpose of molecules is to allow blank nodes to be distributed without loss of information or context.  The context in an RDF molecule allows node ids in blank nodes to be discarded and blank nodes are equal or unequal based on the context within an RDF molecule.

The structure of an RDF molecule is a recursive structure - RDF molecules contain other RDF molecules through linking triples.  For example, a set of triples:
{{{
{_:1  observedInteraction _:2}
{_:2 participant _:3}
{_:3 hasUniprotID ‘p32379’}
{_:2 participant _:4}
{_:4 hasUniprotID ‘p46949’}
}}}

Can be represented in an RDF molecule as:
{{{
{_  observedInteraction _}
  {_ participant _}
    {_ hasUniprotID ‘p32379’}
  {_ participant _}
    {_ hasUniprotID ‘p46949’}
}}}

Where the first level of the molecule contains 1 triple, the second level contains 2 triples and each of the 3rd levels contains another triple.  Triples with two blank nodes are know as link triples.

RDF molecules are also ordered.  For two nodes the ordering is determined by the following rules:
  * Subject, predicate and object nodes in a triple are compared with each other.
  * Node Type
    * Blank node type, is less than;
    * URI Reference node type, is less than;
    * Literal node type.
  * Node Value
    * Comparison of string value based on N3 serialization.

For example: s p o > `_` p o > `_` p `_`

Triples that contain at least one blank node are known as "ungrounded triples".  Triples that contain no blank nodes are "grounded triples".

As most RDF data will already be in local RDF format we need a way to decompose RDF graphs into molecules.  This process can also be used to remove redundant RDF triples and so produce a lean RDF graph. 

= Decomposing =
{{{
Initialize AT, the set of added triples.

LGT is Sorted Local Graph Triples in Descending Order (defined above)
FOR EACH Triple T from LGT not in AT 
    create a new molecule M
    IF T is Grounded THEN
        Add T to AT
    ELSE IF T is Ungrounded THEN
        find all Triples which contain T’s blank nodes
        IF T is a Link Triple (contains a blank node as both subject and object) THEN
            Find any triple T’ which has the same subject as T’s object 
            add T’ to a new molecule SM.  
            IF SM contains a triple that is a link triple and matches the head triple of M THEN
                add M to SM.  
                The molecule used now becomes SM – that is M = SM.
            ELSE 
                Add SM to M.
                Add all triples found to the set AT.
            END IF
        ELSE
            Add T to the molecule M and the set AT.
        END IF
    END IF
END FOR
}}}

= Blank Node Mapping =
{{{
findBlankNodeMap(m1, m2)

initialize BM, the mapping of blank nodes of m1 and m2
FOR EACH root triple t1 in m1
        Find the corresponding blank node t2 in m2
        LET sm1 = m1.submolecule for t1
        LET sm2 = m2. submolecule for t2
        IF sm1 != null AND sm2 != null THEN
               nm = findBlankNodeMap(sm1, sm2)
               IF nm = empty THEN
                      return empty map
               ELSE
                      add nm to BM
               END IF
        ELSE IF t1.submolecule = null AND t2.submolecule = null THEN
               add map between blank nodes in t1 and t2
        ELSE 
               return empty map
        END IF
END FOR
}}}

= Molecule Merging =
{{{
Merge(m1, m2, map)

create new molecule m3
make the blank nodes in m2 the same using the map
add root triples of m1 and m2 to root triples of m3
FOR EACH t1 = root triple of m3
        LET sm1 = m1.submolecule for t1
        LET sm2 = m2.submolecule for t1
        IF sm1 != null AND sm2 != null THEN
              sm3 = merge(sm1, sm2, map)
              add sm3 to m3 off root triple t1
        END IF
END FOR
}}}